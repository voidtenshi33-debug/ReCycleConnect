/**
 * @fileoverview Firestore Security Rules for ReCycleConnect.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data ownership and prevents unauthorized access to private user information.
 * Public data (e.g., items) is readable by everyone, but write access is restricted to the owner.
 * Conversations and messages are secured to only allow access to participants.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, where {userId} is the Firebase Auth UID.
 * - /items/{itemId}: Items listed for exchange. Each item has an `ownerId` field.
 * - /conversations/{conversationId}: Chat sessions between users, secured via the `participants` array.
 * - /conversations/{conversationId}/messages/{messageId}: Individual chat messages.
 * - /exchanges/{exchangeId}: Exchange requests between users for specific items.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Items are publicly readable, but only the owner can modify or delete them.
 * - Conversations are private and only accessible to the participants.
 * - Listing of users is disallowed.
 *
 * Denormalization for Authorization:
 * - Items store the `ownerId` to allow easy enforcement of ownership rules without additional `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Users can only read/write their own profile.
     * @path /users/{userId}
     * @allow (create) User with UID 'user_abc' can create their own profile.
     *          request.auth.uid == 'user_abc' && request.resource.data.userId == 'user_abc'
     * @allow (get, update, delete) User with UID 'user_abc' can read/write their own profile.
     *          request.auth.uid == 'user_abc' && resource.data.userId == 'user_abc'
     * @deny (create) User with UID 'user_abc' cannot create a profile for 'user_xyz'.
     *          request.auth.uid == 'user_abc' && request.resource.data.userId == 'user_xyz'
     * @deny (get, update, delete) User with UID 'user_abc' cannot read/write profile of 'user_xyz'.
     *          request.auth.uid == 'user_abc' && resource.data.userId == 'user_xyz'
     * @principle Enforces user-ownership: only the authenticated user can access their own profile.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false; // Do not allow listing all users.
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId) && resource.data.userId == userId;
      allow delete: if isOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Secure items listed for exchange. Items are publicly readable, but only the owner can modify or delete them.
     * @path /items/{itemId}
     * @allow (get, list) Anyone can read any item.
     * @allow (create) User with UID 'user_abc' can create an item with ownerId 'user_abc'.
     *          request.auth.uid == 'user_abc' && request.resource.data.ownerId == 'user_abc'
     * @allow (update, delete) User with UID 'user_abc' can update/delete an item they own.
     *          request.auth.uid == 'user_abc' && resource.data.ownerId == 'user_abc' && resource != null
     * @deny (create) User with UID 'user_abc' cannot create an item with ownerId 'user_xyz'.
     *          request.auth.uid == 'user_abc' && request.resource.data.ownerId == 'user_xyz'
     * @deny (update, delete) User with UID 'user_abc' cannot update/delete an item owned by 'user_xyz'.
     *          request.auth.uid == 'user_abc' && resource.data.ownerId == 'user_xyz'
     * @principle Public read, owner-only writes.
     */
    match /items/{itemId} {
      function isOwner(ownerId) {
        return request.auth.uid == ownerId;
      }

      allow get, list: if true;
      allow create: if isOwner(request.resource.data.ownerId);
      allow update: if isOwner(resource.data.ownerId) && resource != null;
      allow delete: if isOwner(resource.data.ownerId) && resource != null;
    }

    /**
     * @description Secure conversations between users. Only participants can access a conversation.
     * @path /conversations/{conversationId}
     * @allow (get, list) User with UID 'user_abc' can read if they are a participant.
     *          request.auth.uid == 'user_abc' && 'user_abc' in resource.data.participants
     * @allow (create) User with UID 'user_abc' can create a conversation if they are a participant.
     *          request.auth.uid == 'user_abc' && 'user_abc' in request.resource.data.participants
     * @allow (update, delete) User with UID 'user_abc' can update/delete if they are a participant.
     *          request.auth.uid == 'user_abc' && 'user_abc' in resource.data.participants && resource != null
     * @deny (get, list, create, update, delete) User with UID 'user_abc' cannot access if they are not a participant.
     *          request.auth.uid == 'user_abc' && !('user_abc' in resource.data.participants)
     * @principle Shared access: only participants have access.
     */
    match /conversations/{conversationId} {
        function isParticipant() {
            return request.auth.uid in resource.data.participants;
        }
        allow get, list: if request.auth.uid != null && isParticipant();
        allow create: if request.auth.uid != null && request.resource.data.participants.hasAll([request.auth.uid]);
        allow update: if request.auth.uid != null && isParticipant() && resource != null;
        allow delete: if request.auth.uid != null && isParticipant() && resource != null;
    }

    /**
     * @description Secure messages within a conversation. Only participants of the conversation can access the messages.
     * @path /conversations/{conversationId}/messages/{messageId}
     * @allow (get, list) User with UID 'user_abc' can read messages if they are a participant in the conversation.
     *          request.auth.uid == 'user_abc' && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants.hasAny(['user_abc'])
     * @allow (create) User with UID 'user_abc' can create a message if they are a participant in the conversation.
     *          request.auth.uid == 'user_abc' && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants.hasAny(['user_abc'])
     * @deny (get, list, create) User with UID 'user_abc' cannot access messages if they are not a participant in the conversation.
     *          request.auth.uid == 'user_abc' && !get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants.hasAny(['user_abc'])
     * @principle Shared access: only participants have access.
     */
    match /conversations/{conversationId}/messages/{messageId} {
        function isConversationParticipant() {
            return get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants.hasAny([request.auth.uid]);
        }
        allow get, list: if request.auth.uid != null && isConversationParticipant();
        allow create: if request.auth.uid != null && isConversationParticipant();
        allow update, delete: if false;
    }

    /**
     * @description Secure exchange requests between users.
     * @path /exchanges/{exchangeId}
     * @allow (get, list, create, update, delete) No specific rules defined. Open access.
     * @principle No specific security measures defined in the prompt, so rules are permissive.
     */
    match /exchanges/{exchangeId} {
        allow get, list: if true;
        allow create, update, delete: if true;
    }
  }
}